diff --git a/src/attacher.c b/src/attacher.c
index 460f1ea..5982a93 100644
--- a/src/attacher.c
+++ b/src/attacher.c
@@ -133,6 +133,48 @@ struct msg *m;
   return 0;
 }
 
+int
+WriteOldMessage(struct msg *m)
+{
+  sleep(1); /* give the server some time to reopen the pipe */
+  if (m->type == MSG_ATTACH && (m->m.attach.detachfirst == MSG_ATTACH ||
+				m->m.attach.detachfirst == MSG_DETACH ||
+				m->m.attach.detachfirst == MSG_POW_DETACH))
+    {
+      struct old_msg old_m;
+      int s;
+      int r, l = sizeof(old_m);
+
+      s = MakeClientSocket(0);
+      if (s < 0)
+	return 0;
+      old_m.protocol_revision = (('m'<<24) | ('s'<<16) | ('g'<<8) | 2);
+      old_m.type = m->type;
+      memcpy(old_m.m_tty, m->m_tty, sizeof(old_m.m_tty));
+      memcpy(old_m.m.attach.auser, m->m.attach.auser, sizeof(old_m.m.attach.auser));
+      old_m.m.attach.apid = m->m.attach.apid;
+      old_m.m.attach.adaptflag = m->m.attach.adaptflag;
+      old_m.m.attach.lines = m->m.attach.lines;
+      old_m.m.attach.columns = m->m.attach.columns;
+      memcpy(old_m.m.attach.preselect, m->m.attach.preselect, sizeof(old_m.m.attach.preselect));
+      old_m.m.attach.esc = m->m.attach.esc;
+      old_m.m.attach.meta_esc = m->m.attach.meta_esc;
+      memcpy(old_m.m.attach.envterm, m->m.attach.envterm, sizeof(old_m.m.attach.envterm));
+      old_m.m.attach.encoding = m->m.attach.encoding;
+      while(l > 0)
+        {
+          r = write(s, (char *)&old_m + (sizeof(struct old_msg) - l), l);
+          if (r == -1 && errno == EINTR)
+    	continue;
+          if (r == -1 || r == 0)
+    	return -1;
+          l -= r;
+        }
+      close(s);
+    }
+  return 0;
+}
+
 
 int
 Attach(how)
@@ -397,6 +439,7 @@ int how;
   if (WriteMessage(lasts, &m))
     Panic(errno, "WriteMessage");
   close(lasts);
+  WriteOldMessage(&m);
   debug1("Attach(%d): sent\n", m.type);
 #ifdef MULTIUSER
   if (multi && (how == MSG_ATTACH || how == MSG_CONT))
diff --git a/src/screen.h b/src/screen.h
index b95f8a2..fb4a8d4 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -240,6 +240,60 @@ struct msg
     } m;
 };
 
+struct old_msg
+{
+  int protocol_revision;	/* reduce harm done by incompatible messages */
+  int type;
+  char m_tty[MAXPATHLEN];	/* ttyname */
+  union
+    {
+      struct
+	{
+	  int lflag;
+	  int aflag;
+	  int flowflag;
+	  int hheight;		/* size of scrollback buffer */
+	  int nargs;
+	  char line[MAXPATHLEN];
+	  char dir[MAXPATHLEN];
+	  char screenterm[20];	/* is screen really "screen" ? */
+	}
+      create;
+      struct
+	{
+	  char auser[20 + 1];	/* username */
+	  int apid;		/* pid of frontend */
+	  int adaptflag;	/* adapt window size? */
+	  int lines, columns;	/* display size */
+	  char preselect[20];
+	  int esc;		/* his new escape character unless -1 */
+	  int meta_esc;		/* his new meta esc character unless -1 */
+	  char envterm[40 + 1];	/* terminal type */
+	  int encoding;		/* encoding of display */
+      int detachfirst;
+	}
+      attach;
+      struct 
+	{
+	  char duser[20 + 1];	/* username */
+	  int dpid;		/* pid of frontend */
+	}
+      detach;
+      struct 
+	{
+	  char auser[20 + 1];	/* username */
+	  int nargs;
+	  char cmd[MAXPATHLEN];	/* command */
+	  int apid;		/* pid of frontend */
+	  char preselect[20];
+      char writeback[MAXPATHLEN];
+	}
+      command;
+      char message[MAXPATHLEN * 2];
+    } m;
+};
+
+
 /*
  * And the signals the attacher receives from the backend
  */
diff --git a/src/socket.c b/src/socket.c
index 32c5047..d5a3d74 100644
--- a/src/socket.c
+++ b/src/socket.c
@@ -1067,7 +1067,9 @@ ReceiveMsg()
     }
   if (left > 0)
     {
-      if (left != sizeof(m))
+      if (left == sizeof(struct msg) - sizeof(struct old_msg))
+	    ;/* old format message, ignore */
+      else if (left != sizeof(m))
         Msg(0, "Message %d of %d bytes too small", left, (int)sizeof(m));
       else
 	debug("No data on socket.\n");
